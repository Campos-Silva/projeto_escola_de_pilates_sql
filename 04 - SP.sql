-- 1) CRIANDO STORED PROCEDURE PARA CONSULTA DE AGENDAMENTO PARA NOVOS CLIENTES
DELIMITER //
CREATE PROCEDURE SP_CRIAR_NOVO_CLIENTE(
	P_CPF BIGINT, 
    P_NOME VARCHAR(100),
    P_SOBRENOME VARCHAR(100),
    P_DATA_NASCIMENTO DATE,
    P_GENERO VARCHAR(1),
    P_DATA_DE_CADASTRO DATE)
BEGIN
    -- Inserindo novos clientes a partir dos parâmetros:
    INSERT INTO TB_CLIENTES(CPF, NOME, SOBRENOME, DATA_NASCIMENTO, GENERO, DATA_DE_CADASTRO)
		 VALUES (P_CPF, P_NOME, P_SOBRENOME, P_DATA_NASCIMENTO, P_GENERO, P_DATA_DE_CADASTRO);
END//

-- INSERINDO UM NOVO CLIENTE (TESTE):
CALL SP_CRIAR_NOVO_CLIENTE(3567890764, 'NAYANE', 'DUARTE', '1990-03-08', 'F', '2023-09-26');
CALL SP_CRIAR_NOVO_CLIENTE(1234555577, 'MARIA', 'SILVA', '1994-07-08', 'N', '2023-09-28');
CALL SP_CRIAR_NOVO_CLIENTE(1234554357, 'MARIA', 'PEREIRA', '1994-07-08', 'N', '2023-09-28');
CALL SP_CRIAR_NOVO_CLIENTE(1234456357, 'PEDRO', 'JOSÉ', '1998-07-08', 'M', '2023-09-28');
CALL SP_CRIAR_NOVO_CLIENTE(1234566357, 'DANIEL', 'NOGUEIRA', '1988-02-26', 'M', '2023-09-28');

-------------------------------------------------------------------------------

-- 2) CRIANDO UMA STORED PROCEDURE PARA INSERIR NOVOS CONTRATOS
DELIMITER //
CREATE PROCEDURE SP_INSERIR_CONTRATO_PLANO(
    ID_CLIENTE INT,
    ID_PLANO INT,
    DATA_INICIO DATE,
    DATA_TERMINO DATE,
    STATUS_ASSOCIACAO VARCHAR(255)
)
BEGIN
    INSERT INTO TB_CONTRATOS_PLANOS (ID_CLIENTE, ID_PLANO, DATA_INICIO, DATA_TERMINO, STATUS_ASSOCIACAO)
    VALUES (ID_CLIENTE, ID_PLANO, DATA_INICIO, DATA_TERMINO, STATUS_ASSOCIACAO);
END //


-- INSERINDO UM NOVO CONTRATO (TESTE):
CALL SP_INSERIR_CONTRATO_PLANO(29, 1, '2023-09-26', '2023-10-26', 'ATIVO');
CALL SP_INSERIR_CONTRATO_PLANO(30, 1, '2023-09-28', '2023-10-28', 'ATIVO');
CALL SP_INSERIR_CONTRATO_PLANO(31, 2, '2023-09-28', '2023-10-28', 'ATIVO');
CALL SP_INSERIR_CONTRATO_PLANO(32, 2, '2023-09-28', '2023-10-28', 'INATIVO');

-- CHECANDO O CONTRATO CRIADO:
SELECT * FROM TB_CONTRATOS_PLANOS;

-------------------------------------------------------------------------------

-- 3) CRIANDO STORED PROCEDURE PARA CONSULTA DE AGENDAMENTO

-- 1° -> CRIAÇÃO DE FUNÇÃO DE DISPONIBILIDADE DE AGENDA
DELIMITER //
CREATE FUNCTION FN_RETORNAR_DISPONIBILIDADE_AULA(P_AGENDA BIGINT)
RETURNS INT
DETERMINISTIC
BEGIN 
	DECLARE V_CAPACIDADE INT DEFAULT 0;
    DECLARE V_AGENDAMENTOS INT DEFAULT 0;  
    DECLARE V_AGENDA_ENCONTRADA INT DEFAULT 0;
    
    SELECT COUNT(*) INTO V_AGENDA_ENCONTRADA FROM TB_AGENDA WHERE ID_AGENDA = P_AGENDA;
    
    IF V_AGENDA_ENCONTRADA = 1 THEN
		SELECT COUNT(ID_CLIENTE) INTO V_AGENDAMENTOS 
		FROM TB_AGENDAMENTOS 
		WHERE ID_AGENDA = P_AGENDA GROUP BY ID_AGENDA; 

        SELECT AU.CAPACIDADE_ALUNO INTO V_CAPACIDADE FROM TB_AULAS AU INNER JOIN TB_AGENDA AG USING(ID_AULA) WHERE AG.ID_AGENDA = P_AGENDA;
        
		RETURN V_CAPACIDADE - V_AGENDAMENTOS;
    
    ELSE 
    
		RETURN -1;
        
    END IF;
    
END//

SELECT FN_RETORNAR_DISPONIBILIDADE_AULA(19); -- teste

-- 2° -> CRIAÇÃO DE SP DE RETORNO DE CONSULTA DE DISPONIBILIDADE DE AGENDAS

DELIMITER //
CREATE PROCEDURE SP_RETORNAR_DISPONIBILIDADE_AULA(P_AGENDA BIGINT)
BEGIN
	DECLARE V_DISPONIBILIDADE INT DEFAULT 0;
    DECLARE V_AULA VARCHAR(100);
	
    SELECT FN_RETORNAR_DISPONIBILIDADE_AULA(P_AGENDA) INTO V_DISPONIBILIDADE;
	SELECT AU.NOME_AULA INTO V_AULA FROM TB_AULAS AU INNER JOIN TB_AGENDA AG USING(ID_AULA) WHERE AG.ID_AGENDA = P_AGENDA;
    
    CASE
		WHEN V_DISPONIBILIDADE = 0 THEN
			SELECT CONCAT('Aula ', V_AULA, ' Indisponível') AS 'Resultado';
		WHEN V_DISPONIBILIDADE > 0 THEN
			SELECT CONCAT('Aula ', V_AULA, ' Disponível') AS 'Resultado';
		WHEN V_DISPONIBILIDADE < 0 THEN
			SELECT 'Aula não existe' AS 'Resultado';
	END CASE;
END//

-- TESTES

-- Aula disponível
CALL SP_RETORNAR_DISPONIBILIDADE_AULA(10);
-- Aula indisponível
CALL SP_RETORNAR_DISPONIBILIDADE_AULA(14);
-- Aula não existe
CALL SP_RETORNAR_DISPONIBILIDADE_AULA(99);

-------------------------------------------------------------------------------

-- 4) CRIANDO STORED PROCEDURE PARA INSERIR NOVO AGENDAMENTO

DELIMITER //
CREATE PROCEDURE SP_INCLUSAO_NOVO_AGENDAMENTO(P_CLIENTE BIGINT, P_AGENDA BIGINT)
BEGIN
	DECLARE V_DISPONIBILIDADE INT DEFAULT 0;
    DECLARE V_LIMITE_CONTRATUAL INT DEFAULT 0;
    DECLARE V_AGENDAMENTOS_CLIENTE  INT DEFAULT 0;
    DECLARE V_VALIDACAO_AGENDAMENTO_EXISTENTE INT DEFAULT 0;
    DECLARE V_STATUS_CONTRATO VARCHAR(100);
	
    SELECT FN_RETORNAR_DISPONIBILIDADE_AULA(P_AGENDA) INTO V_DISPONIBILIDADE;
    SELECT TP.FREQUENCIA_SEMANAL INTO V_LIMITE_CONTRATUAL
		FROM TB_TIPOS_DE_PLANOS TP INNER JOIN TB_CONTRATOS_PLANOS CP USING(ID_PLANO)
        WHERE CP.ID_CLIENTE = P_CLIENTE;
	SELECT COUNT(ID_AGENDAMENTO) INTO V_AGENDAMENTOS_CLIENTE
		FROM TB_AGENDAMENTOS
        WHERE ID_CLIENTE = P_CLIENTE;
    SELECT COUNT(ID_AGENDAMENTO) INTO V_VALIDACAO_AGENDAMENTO_EXISTENTE
		FROM TB_AGENDAMENTOS
        WHERE ID_CLIENTE = P_CLIENTE AND ID_AGENDA = P_AGENDA;
	SELECT STATUS_ASSOCIACAO INTO V_STATUS_CONTRATO
		FROM TB_CONTRATOS_PLANOS
        WHERE ID_CLIENTE = P_CLIENTE;
    
    CASE

   -- Agendamento sem sucesso, contrato inativo
		WHEN  V_STATUS_CONTRATO = 'Inativo' THEN
			SELECT CONCAT('Contrato do cliente está inativo') AS 'Resultado';

    -- Agendamento sem sucesso, agendamento em duplicidade para o cliente
		WHEN  V_VALIDACAO_AGENDAMENTO_EXISTENTE > 0 THEN
			SELECT CONCAT('Agendamento em duplicidade para o cliente') AS 'Resultado';
    
    -- Agendamento com sucesso
		WHEN V_DISPONIBILIDADE > 0 AND (V_LIMITE_CONTRATUAL - V_AGENDAMENTOS_CLIENTE) > 0 AND V_STATUS_CONTRATO = 'Ativo' THEN
			INSERT INTO TB_AGENDAMENTOS(ID_CLIENTE, ID_AGENDA) VALUES (P_CLIENTE, P_AGENDA);
			SELECT CONCAT('Agendamento concluído com sucesso') AS 'Resultado';
	
	-- Agendamento sem sucesso, indisponibilidade de agendamento
		WHEN V_DISPONIBILIDADE = 0 THEN
			SELECT 'Aula indisponível para agendamento' AS 'Resultado';
            
	 -- Agendamento sem sucesso, limite contratual excedido ou aula não existe
		WHEN V_DISPONIBILIDADE < 0 THEN
			SELECT 'Aula não existe' AS 'Resultado';
        
	-- Limitações contratuais - limite excedido ou contrato não existe
		ELSE SELECT 'Agendamento não realizado - checar se o contrato e cliente existem ou se seu limite foi excedido' AS 'Resultado';

	END CASE;
END//

-- TESTES

-- Aula indisponível
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(1, 14);
-- Aula não existe
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(1, 199);
-- Limite contratual excedido
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(1, 19);
-- Contrato não existe
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(33, 19);
-- Cliente não existe
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(99, 19);
-- Agendamento concluído com sucesso + Limite contratual excedido
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(30, 19); -- 1° agendamento
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(30, 3); -- contrato excedido
-- Agendamento em duplicidade
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(31, 1); -- agendar primeira vez
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(31, 1); -- duplicidade
-- Contrato inativo
CALL SP_INCLUSAO_NOVO_AGENDAMENTO(32, 1);

-------------------------------------------------------------------------------

-- 5) CRIANDO STORED PROCEDURE QUE CHECA SE O STATUS DE PAGAMENTO ESTÁ PENDENTE (2 OU 7) COM MAIS DE 5 DIAS DE ATRASO E ATUALIZA PARA "CANCELADO - FALTA DE PAGAMENTO" (12)
DELIMITER $

CREATE PROCEDURE SP_ROTINA_INATIVACAO_CONTRATOS()
BEGIN

UPDATE TB_REGISTRO_INDIVIDUAL_DE_PAGAMENTO_DO_PLANO
SET ID_DO_STATUS = 12
WHERE DATA_DO_PAGAMENTO IS NULL
  AND (ID_DO_STATUS = 2 OR ID_DO_STATUS = 7)
  AND DATEDIFF(CURDATE(), DATA_VENCIMENTO) > 5;

END $

-- 6) CRIANDO STORED PROCEDURE QUE DELETA TODOS OS AGENDAMENTOS DE CONTRATOS COM PAGAMENTO STATUS 12 PELA ROTINA DE ATRASO > 5 DIAS
DELIMITER $

CREATE PROCEDURE SP_ROTINA_INATIVACAO_CONTRATOS2_AGENDAMENTOS(P_CONTRATO BIGINT)
BEGIN
    -- Exclua os agendamentos associados ao contrato
    DELETE FROM TB_AGENDAMENTOS
    WHERE ID_CLIENTE IN (SELECT ID_CLIENTE FROM TB_CONTRATOS_PLANOS WHERE ID_CONTRATO = P_CONTRATO);

END $